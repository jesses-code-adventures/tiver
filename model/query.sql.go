// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package model

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one
INSERT INTO game DEFAULT VALUES RETURNING id, created_at, ended_at, requests
`

func (q *Queries) CreateGame(ctx context.Context) (Game, error) {
	row := q.db.QueryRow(ctx, createGame)
	var i Game
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.EndedAt,
		&i.Requests,
	)
	return i, err
}

const createRequest = `-- name: CreateRequest :one
INSERT INTO request (id, created_at, game_id, colour, origin, speed, width, status) values (DEFAULT, DEFAULT, $1, $2, $3, $4, $5, $6) RETURNING id, created_at, ended_at, game_id, colour, origin, speed, width, status
`

type CreateRequestParams struct {
	GameID pgtype.UUID
	Colour string
	Origin Origin
	Speed  int32
	Width  int32
	Status RequestStatus
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (Request, error) {
	row := q.db.QueryRow(ctx, createRequest,
		arg.GameID,
		arg.Colour,
		arg.Origin,
		arg.Speed,
		arg.Width,
		arg.Status,
	)
	var i Request
	err := row.Scan(
		&i.Id,
		&i.CreatedAt,
		&i.EndedAt,
		&i.GameID,
		&i.Colour,
		&i.Origin,
		&i.Speed,
		&i.Width,
		&i.Status,
	)
	return i, err
}

const decrementRequests = `-- name: DecrementRequests :exec
UPDATE game
SET requests = requests + 1
WHERE id = $1
`

func (q *Queries) DecrementRequests(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, decrementRequests, id)
	return err
}

const getActiveGames = `-- name: GetActiveGames :many
SELECT id, created_at, ended_at, requests FROM game where ended_at = NULL order by created_at asc
`

func (q *Queries) GetActiveGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, getActiveGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.EndedAt,
			&i.Requests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHangingRequests = `-- name: GetHangingRequests :many
SELECT id, created_at, ended_at, requests FROM game WHERE ended_at IS NOT NULL AND requests > 0
`

func (q *Queries) GetHangingRequests(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, getHangingRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.Id,
			&i.CreatedAt,
			&i.EndedAt,
			&i.Requests,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementRequests = `-- name: IncrementRequests :exec
UPDATE game
SET requests = requests + 1
WHERE id = $1
`

func (q *Queries) IncrementRequests(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementRequests, id)
	return err
}

const updateEndGame = `-- name: UpdateEndGame :exec
UPDATE game SET ended_at = $2 WHERE id = $1
`

type UpdateEndGameParams struct {
	Id      pgtype.UUID
	EndedAt pgtype.Timestamptz
}

func (q *Queries) UpdateEndGame(ctx context.Context, arg UpdateEndGameParams) error {
	_, err := q.db.Exec(ctx, updateEndGame, arg.Id, arg.EndedAt)
	return err
}

const updateEndRequest = `-- name: UpdateEndRequest :exec
UPDATE request SET status = $2, ended_at = $3 WHERE id = $1
`

type UpdateEndRequestParams struct {
	Id      pgtype.UUID
	Status  RequestStatus
	EndedAt pgtype.Timestamptz
}

func (q *Queries) UpdateEndRequest(ctx context.Context, arg UpdateEndRequestParams) error {
	_, err := q.db.Exec(ctx, updateEndRequest, arg.Id, arg.Status, arg.EndedAt)
	return err
}

const updateRequestStatus = `-- name: UpdateRequestStatus :exec
UPDATE request SET status = $2 WHERE id = $1
`

type UpdateRequestStatusParams struct {
	Id     pgtype.UUID
	Status RequestStatus
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) error {
	_, err := q.db.Exec(ctx, updateRequestStatus, arg.Id, arg.Status)
	return err
}
